// Code generated by protoc-gen-go-orb. DO NOT EDIT.
//
// version:
// - protoc-gen-go-orb        v0.0.1
// - protoc                   v5.29.2
//
// Proto source: file/file.proto

package file

import (
	"context"
	"fmt"

	"github.com/go-orb/go-orb/client"
	"github.com/go-orb/go-orb/log"
	"github.com/go-orb/go-orb/server"

	"google.golang.org/protobuf/proto"
	"storj.io/drpc"

	grpc "google.golang.org/grpc"

	mdrpc "github.com/go-orb/plugins/server/drpc"
	memory "github.com/go-orb/plugins/server/memory"

	mhttp "github.com/go-orb/plugins/server/http"
)

// HandlerFileService is the name of a service, it's here to static type/reference.
const HandlerFileService = "file.FileService"
const EndpointFileServiceUploadFile = "/file.FileService/UploadFile"
const EndpointFileServiceAuthorizedUploadFile = "/file.FileService/AuthorizedUploadFile"

// orbEncoding_FileService_proto is a protobuf encoder for the file.FileService service.
type orbEncoding_FileService_proto struct{}

// Marshal implements the drpc.Encoding interface.
func (orbEncoding_FileService_proto) Marshal(msg drpc.Message) ([]byte, error) {
	m, ok := msg.(proto.Message)
	if !ok {
		return nil, fmt.Errorf("message is not a proto.Message: %T", msg)
	}
	return proto.Marshal(m)
}

// Unmarshal implements the drpc.Encoding interface.
func (orbEncoding_FileService_proto) Unmarshal(data []byte, msg drpc.Message) error {
	m, ok := msg.(proto.Message)
	if !ok {
		return fmt.Errorf("message is not a proto.Message: %T", msg)
	}
	return proto.Unmarshal(data, m)
}

// Name implements the drpc.Encoding interface.
func (orbEncoding_FileService_proto) Name() string {
	return "proto"
}

// FileServiceClient is the client for file.FileService
type FileServiceClient struct {
	client client.Client
}

// NewFileServiceClient creates a new client for file.FileService
func NewFileServiceClient(client client.Client) *FileServiceClient {
	return &FileServiceClient{client: client}
}

// UploadFile creates a client-streaming connection to UploadFile.
func (c *FileServiceClient) UploadFile(ctx context.Context, service string, opts ...client.CallOption) (client.StreamIface[*FileChunk, *UploadResponse], error) {
	return client.Stream[*FileChunk, *UploadResponse](ctx, c.client, service, EndpointFileServiceUploadFile, opts...)
}

// AuthorizedUploadFile creates a client-streaming connection to AuthorizedUploadFile.
func (c *FileServiceClient) AuthorizedUploadFile(ctx context.Context, service string, opts ...client.CallOption) (client.StreamIface[*FileChunk, *UploadResponse], error) {
	return client.Stream[*FileChunk, *UploadResponse](ctx, c.client, service, EndpointFileServiceAuthorizedUploadFile, opts...)
}

// FileServiceHandler is the Handler for file.FileService
type FileServiceHandler interface {
	UploadFile(stream FileServiceUploadFileStream) error

	AuthorizedUploadFile(stream FileServiceAuthorizedUploadFileStream) error
}

// FileServiceUploadFileStream defines the streaming interface for UploadFile
type FileServiceUploadFileStream interface {
	Send(*UploadResponse) error
	Recv() (*FileChunk, error)
	Context() context.Context
	Close() error
	CloseSend(*UploadResponse) error
}

// FileServiceAuthorizedUploadFileStream defines the streaming interface for AuthorizedUploadFile
type FileServiceAuthorizedUploadFileStream interface {
	Send(*UploadResponse) error
	Recv() (*FileChunk, error)
	Context() context.Context
	Close() error
	CloseSend(*UploadResponse) error
}

// orbGRPCFileService provides the adapter to convert a FileServiceHandler to a gRPC FileServiceServer.
type orbGRPCFileService struct {
	handler FileServiceHandler
}

// UploadFile implements the FileServiceServer interface by adapting to the FileServiceHandler.
func (s *orbGRPCFileService) UploadFile(stream grpc.ClientStreamingServer[FileChunk, UploadResponse]) error {
	// Adapt the gRPC stream to the ORB stream
	adapter := &orbGRPCUploadFileStreamAdapter{
		stream: stream,
	}
	return s.handler.UploadFile(adapter)
}

// AuthorizedUploadFile implements the FileServiceServer interface by adapting to the FileServiceHandler.
func (s *orbGRPCFileService) AuthorizedUploadFile(stream grpc.ClientStreamingServer[FileChunk, UploadResponse]) error {
	// Adapt the gRPC stream to the ORB stream
	adapter := &orbGRPCAuthorizedUploadFileStreamAdapter{
		stream: stream,
	}
	return s.handler.AuthorizedUploadFile(adapter)
}

// Stream adapters to convert gRPC streams to ORB streams.

// orbGRPCUploadFileStreamAdapter adapts a gRPC stream to the ORB FileServiceUploadFileStream interface.
type orbGRPCUploadFileStreamAdapter struct {
	stream grpc.ClientStreamingServer[FileChunk, UploadResponse]
}

func (a *orbGRPCUploadFileStreamAdapter) Recv() (*FileChunk, error) {
	return a.stream.Recv()
}

func (a *orbGRPCUploadFileStreamAdapter) Context() context.Context {
	return a.stream.Context()
}

func (a *orbGRPCUploadFileStreamAdapter) Close() error {
	// gRPC streams don't have a direct Close method, so we'll return nil.
	return nil
}

func (a *orbGRPCUploadFileStreamAdapter) Send(resp *UploadResponse) error {
	return a.stream.SendAndClose(resp)
}

func (a *orbGRPCUploadFileStreamAdapter) CloseSend(resp *UploadResponse) error {
	return a.stream.SendAndClose(resp)
}

// orbGRPCAuthorizedUploadFileStreamAdapter adapts a gRPC stream to the ORB FileServiceAuthorizedUploadFileStream interface.
type orbGRPCAuthorizedUploadFileStreamAdapter struct {
	stream grpc.ClientStreamingServer[FileChunk, UploadResponse]
}

func (a *orbGRPCAuthorizedUploadFileStreamAdapter) Recv() (*FileChunk, error) {
	return a.stream.Recv()
}

func (a *orbGRPCAuthorizedUploadFileStreamAdapter) Context() context.Context {
	return a.stream.Context()
}

func (a *orbGRPCAuthorizedUploadFileStreamAdapter) Close() error {
	// gRPC streams don't have a direct Close method, so we'll return nil.
	return nil
}

func (a *orbGRPCAuthorizedUploadFileStreamAdapter) Send(resp *UploadResponse) error {
	return a.stream.SendAndClose(resp)
}

func (a *orbGRPCAuthorizedUploadFileStreamAdapter) CloseSend(resp *UploadResponse) error {
	return a.stream.SendAndClose(resp)
}

// Verification that our adapters implement the required interfaces.
var _ FileServiceUploadFileStream = (*orbGRPCUploadFileStreamAdapter)(nil)
var _ FileServiceAuthorizedUploadFileStream = (*orbGRPCAuthorizedUploadFileStreamAdapter)(nil)
var _ FileServiceServer = (*orbGRPCFileService)(nil)

// registerFileServiceGRPCServerHandler registers the service to a gRPC server.
func registerFileServiceGRPCServerHandler(srv grpc.ServiceRegistrar, handler FileServiceHandler) {
	// Create the adapter to convert from FileServiceHandler to FileServiceServer
	grpcHandler := &orbGRPCFileService{handler: handler}

	srv.RegisterService(&FileService_ServiceDesc, grpcHandler)
}

// orbDRPCUploadFileClient is the client API for the UploadFile method.
type orbDRPCUploadFileClient interface {
	// Send sends a message through the stream.
	Send(msg *FileChunk) error
	// CloseSend signals to the server that we're done sending messages.
	CloseSend() error
	// Recv receives a message from the stream.
	Recv(m *UploadResponse) error
	// Context returns the stream's context.
	Context() context.Context
}

// orbDRPCUploadFileClientStream implements the UploadFileClient interface.
type orbDRPCUploadFileClientStream struct {
	stream DRPCFileService_UploadFileStream
}

func (s *orbDRPCUploadFileClientStream) Send(msg *FileChunk) error {
	return s.stream.MsgSend(msg, orbEncoding_FileService_proto{})
}
func (s *orbDRPCUploadFileClientStream) Recv(m *UploadResponse) error {
	return s.stream.MsgRecv(m, orbEncoding_FileService_proto{})
}

func (s *orbDRPCUploadFileClientStream) Context() context.Context {
	return s.stream.Context()
}

// orbDRPCAuthorizedUploadFileClient is the client API for the AuthorizedUploadFile method.
type orbDRPCAuthorizedUploadFileClient interface {
	// Send sends a message through the stream.
	Send(msg *FileChunk) error
	// CloseSend signals to the server that we're done sending messages.
	CloseSend() error
	// Recv receives a message from the stream.
	Recv(m *UploadResponse) error
	// Context returns the stream's context.
	Context() context.Context
}

// orbDRPCAuthorizedUploadFileClientStream implements the AuthorizedUploadFileClient interface.
type orbDRPCAuthorizedUploadFileClientStream struct {
	stream DRPCFileService_AuthorizedUploadFileStream
}

func (s *orbDRPCAuthorizedUploadFileClientStream) Send(msg *FileChunk) error {
	return s.stream.MsgSend(msg, orbEncoding_FileService_proto{})
}
func (s *orbDRPCAuthorizedUploadFileClientStream) Recv(m *UploadResponse) error {
	return s.stream.MsgRecv(m, orbEncoding_FileService_proto{})
}

func (s *orbDRPCAuthorizedUploadFileClientStream) Context() context.Context {
	return s.stream.Context()
}

// orbDRPCFileServiceHandler wraps a FileServiceHandler to implement DRPCFileServiceServer.
type orbDRPCFileServiceHandler struct {
	handler FileServiceHandler
}

// UploadFile implements the DRPCFileServiceServer interface by adapting to the FileServiceHandler.
func (w *orbDRPCFileServiceHandler) UploadFile(stream DRPCFileService_UploadFileStream) error {
	// Adapt the DRPC stream to the ORB stream.
	adapter := &orbDRPCUploadFileStreamAdapter{
		stream: stream,
	}
	return w.handler.UploadFile(adapter)
}

// AuthorizedUploadFile implements the DRPCFileServiceServer interface by adapting to the FileServiceHandler.
func (w *orbDRPCFileServiceHandler) AuthorizedUploadFile(stream DRPCFileService_AuthorizedUploadFileStream) error {
	// Adapt the DRPC stream to the ORB stream.
	adapter := &orbDRPCAuthorizedUploadFileStreamAdapter{
		stream: stream,
	}
	return w.handler.AuthorizedUploadFile(adapter)
}

// Stream adapters to convert DRPC streams to ORB streams.

// orbDRPCUploadFileStreamAdapter adapts a DRPC stream to the ORB FileServiceUploadFileStream interface.
type orbDRPCUploadFileStreamAdapter struct {
	stream DRPCFileService_UploadFileStream
}

func (a *orbDRPCUploadFileStreamAdapter) Recv() (*FileChunk, error) {
	return a.stream.Recv()
}

func (a *orbDRPCUploadFileStreamAdapter) Context() context.Context {
	return a.stream.Context()
}

func (a *orbDRPCUploadFileStreamAdapter) Close() error {
	return a.stream.CloseSend()
}

func (a *orbDRPCUploadFileStreamAdapter) Send(resp *UploadResponse) error {
	return a.stream.SendAndClose(resp)
}

func (a *orbDRPCUploadFileStreamAdapter) CloseSend(resp *UploadResponse) error {
	return a.stream.SendAndClose(resp)
}

// orbDRPCAuthorizedUploadFileStreamAdapter adapts a DRPC stream to the ORB FileServiceAuthorizedUploadFileStream interface.
type orbDRPCAuthorizedUploadFileStreamAdapter struct {
	stream DRPCFileService_AuthorizedUploadFileStream
}

func (a *orbDRPCAuthorizedUploadFileStreamAdapter) Recv() (*FileChunk, error) {
	return a.stream.Recv()
}

func (a *orbDRPCAuthorizedUploadFileStreamAdapter) Context() context.Context {
	return a.stream.Context()
}

func (a *orbDRPCAuthorizedUploadFileStreamAdapter) Close() error {
	return a.stream.CloseSend()
}

func (a *orbDRPCAuthorizedUploadFileStreamAdapter) Send(resp *UploadResponse) error {
	return a.stream.SendAndClose(resp)
}

func (a *orbDRPCAuthorizedUploadFileStreamAdapter) CloseSend(resp *UploadResponse) error {
	return a.stream.SendAndClose(resp)
}

// Verification that our adapters implement the required interfaces.
var _ FileServiceUploadFileStream = (*orbDRPCUploadFileStreamAdapter)(nil)
var _ FileServiceAuthorizedUploadFileStream = (*orbDRPCAuthorizedUploadFileStreamAdapter)(nil)
var _ DRPCFileServiceServer = (*orbDRPCFileServiceHandler)(nil)

// registerFileServiceDRPCHandler registers the service to an dRPC server.
func registerFileServiceDRPCHandler(srv *mdrpc.Server, handler FileServiceHandler) error {
	desc := DRPCFileServiceDescription{}

	// Wrap the ORB handler with our adapter to make it compatible with DRPC.
	drpcHandler := &orbDRPCFileServiceHandler{handler: handler}

	// Register with the server/drpc(.Mux).
	err := srv.Router().Register(drpcHandler, desc)
	if err != nil {
		return err
	}

	// Add each endpoint name of this handler to the orb drpc server.
	srv.AddEndpoint("/file.FileService/UploadFile")
	srv.AddEndpoint("/file.FileService/AuthorizedUploadFile")

	return nil
}

// registerFileServiceMemoryHandler registers the service to a memory server.
func registerFileServiceMemoryHandler(srv *memory.Server, handler FileServiceHandler) error {
	desc := DRPCFileServiceDescription{}

	// Wrap the ORB handler with our adapter to make it compatible with DRPC.
	drpcHandler := &orbDRPCFileServiceHandler{handler: handler}

	// Register with the server/drpc(.Mux).
	err := srv.Router().Register(drpcHandler, desc)
	if err != nil {
		return err
	}

	// Add each endpoint name of this handler to the orb drpc server.
	srv.AddEndpoint("/file.FileService/UploadFile")
	srv.AddEndpoint("/file.FileService/AuthorizedUploadFile")

	return nil
}

// registerFileServiceHTTPHandler registers the service to an HTTP server.
func registerFileServiceHTTPHandler(srv *mhttp.Server, handler FileServiceHandler) {
	// HTTP transport does not support streaming for UploadFile
	log.Warn("Streaming endpoint not registered with HTTP transport", "endpoint", "/file.FileService/UploadFile")
	// HTTP transport does not support streaming for AuthorizedUploadFile
	log.Warn("Streaming endpoint not registered with HTTP transport", "endpoint", "/file.FileService/AuthorizedUploadFile")
}

// RegisterFileServiceHandler will return a registration function that can be
// provided to entrypoints as a handler registration.
func RegisterFileServiceHandler(handler any) server.RegistrationFunc {
	return func(s any) {
		switch srv := s.(type) {

		case grpc.ServiceRegistrar:
			registerFileServiceGRPCServerHandler(srv, handler.(FileServiceHandler))
		case *mdrpc.Server:
			registerFileServiceDRPCHandler(srv, handler.(FileServiceHandler))
		case *memory.Server:
			registerFileServiceMemoryHandler(srv, handler.(FileServiceHandler))
		case *mhttp.Server:
			registerFileServiceHTTPHandler(srv, handler.(FileServiceHandler))
		default:
			log.Warn("No provider for this server found", "proto", "file/file.proto", "handler", "FileService", "server", s)
		}
	}
}
