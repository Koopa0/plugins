// Code generated by protoc-gen-go-orb. DO NOT EDIT.
//
// version:
// - protoc-gen-go-orb        v0.0.1
// - protoc                   v5.27.3
//
// Proto source: echo.proto

package proto

import (
	"context"

	"github.com/go-orb/go-orb/log"
	"github.com/go-orb/go-orb/server"

	grpc "google.golang.org/grpc"

	mdrpc "github.com/go-orb/plugins/server/drpc"
	mhertz "github.com/go-orb/plugins/server/hertz"
	mhttp "github.com/go-orb/plugins/server/http"
)

type StreamsHandler interface {
	Call(ctx context.Context, req *CallRequest) (*CallResponse, error)

	AuthorizedCall(ctx context.Context, req *CallRequest) (*CallResponse, error)
}

func registerStreamsDRPCHandler(srv *mdrpc.Server, handler StreamsHandler) error {
	desc := DRPCStreamsDescription{}

	// Register with DRPC.
	r := srv.Router()

	// Register with the server/drpc(.Mux).
	err := r.Register(handler, desc)
	if err != nil {
		return err
	}

	// Add each endpoint name of this handler to the orb drpc server.
	for i := 0; i < desc.NumMethods(); i++ {
		name, _, _, _, _ := desc.Method(i)
		srv.AddEndpoint(name)
	}

	return nil
}

// registerStreamsHTTPHandler registers the service to an HTTP server.
func registerStreamsHTTPHandler(srv *mhttp.ServerHTTP, handler StreamsHandler) {
	r := srv.Router()

	r.Post("/echo.Streams/Call", mhttp.NewGRPCHandler(srv, handler.Call, "echo.Streams", "Call"))
	r.Post("/echo.Streams/AuthorizedCall", mhttp.NewGRPCHandler(srv, handler.AuthorizedCall, "echo.Streams", "AuthorizedCall"))
}

// registerStreamsHertzHandler registers the service to an Hertz server.
func registerStreamsHertzHandler(srv *mhertz.Server, handler StreamsHandler) {
	r := srv.Router()

	r.POST("/echo.Streams/Call", mhertz.NewGRPCHandler(srv, handler.Call, "echo.Streams", "Call"))
	r.POST("/echo.Streams/AuthorizedCall", mhertz.NewGRPCHandler(srv, handler.AuthorizedCall, "echo.Streams", "AuthorizedCall"))
}

// RegisterStreamsHandler will return a registration function that can be
// provided to entrypoints as a handler registration.
func RegisterStreamsHandler(handler StreamsHandler) server.RegistrationFunc {
	return server.RegistrationFunc(func(s any) {
		switch srv := s.(type) {

		case grpc.ServiceRegistrar:
			registerStreamsGRPCHandler(srv, handler)
		case *mdrpc.Server:
			registerStreamsDRPCHandler(srv, handler)
		case *mhertz.Server:
			registerStreamsHertzHandler(srv, handler)
		case *mhttp.ServerHTTP:
			registerStreamsHTTPHandler(srv, handler)
		default:
			log.Warn("No provider for this server found", "proto", "echo.proto", "handler", "Streams", "server", s)
		}
	})
}
