// Code generated by protoc-gen-go-orb-http. DO NOT EDIT.
//
// version:
// - protoc-gen-go-orb-http  v1.0.0
// - protoc                 v4.25.1
//
// Proto source: echo.proto

package echo

import (
	"context"

	"github.com/go-orb/go-orb/server"
	"google.golang.org/grpc"

	mdrpc "github.com/go-orb/plugins/server/drpc"
	mhertz "github.com/go-orb/plugins/server/hertz"
	mhttp "github.com/go-orb/plugins/server/http"
)

type orbEchoHandler interface {
	Echo(ctx context.Context, req *Req) (*Resp, error)
	mustEmbedUnimplementedEchoServer()
}

func registerEchoHTTPHandler(srv *mhttp.ServerHTTP, handler orbEchoHandler) {
	r := srv.Router()
	r.Post("/echo.Echo/Echo", mhttp.NewGRPCHandler(srv, handler.Echo))
}

func registerEchoHertzHandler(srv *mhertz.Server, handler orbEchoHandler) {
	s := srv.Router()
	s.POST("/echo.Echo/Echo", mhertz.NewGRPCHandler(srv, handler.Echo))
}

func registerEchoDRPCHandler(srv *mdrpc.Server, handler orbEchoHandler) error {
	desc := DRPCEchoDescription{}

	// Register with DRPC.
	r := srv.Router()

	// Register with the drpcmux.
	err := r.Register(handler, desc)
	if err != nil {
		return err
	}

	// Add each endpoint name of this handler to the orb drpc server.
	for i := 0; i < desc.NumMethods(); i++ {
		name, _, _, _, _ := desc.Method(i)
		srv.AddEndpoint(name)
	}

	return nil
}

// OrbRegister will return a registration function that can be
// provided to entrypoints as a handler registration.
func OrbRegister(handler EchoServer) server.RegistrationFunc {
	return server.RegistrationFunc(func(s any) {
		switch srv := s.(type) {
		case *mhttp.ServerHTTP:
			registerEchoHTTPHandler(srv, handler.(orbEchoHandler))
		case *mhertz.Server:
			registerEchoHertzHandler(srv, handler.(orbEchoHandler))
		case *mdrpc.Server:
			registerEchoDRPCHandler(srv, handler.(orbEchoHandler)) //nolint:errcheck,gosec
		case grpc.ServiceRegistrar:
			RegisterEchoServer(srv, handler)
		default:
			// Maybe we should log here with slog global logger
		}
	})
}
