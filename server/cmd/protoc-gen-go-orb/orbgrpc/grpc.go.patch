--- grpc.go.upstream	2024-08-12 16:40:01.015276253 +0200
+++ grpc.go	2024-08-12 22:02:36.178076565 +0200
@@ -16,7 +16,10 @@
  *
  */
 
-package main
+// Package orbgrpc is copy&pasted version from protoc-gen-go-grpc.
+//
+//nolint:lll,wsl,gochecknoglobals,varnamelen,funlen,gocritic,revive
+package orbgrpc
 
 import (
 	"fmt"
@@ -28,6 +31,15 @@
 	"google.golang.org/protobuf/types/descriptorpb"
 )
 
+// These get set by protoc-gen-go-orb.
+//
+//nolint:gochecknoglobals
+var (
+	Version              = ""
+	RequireUnimplemented *bool
+	UseGenericStreams    *bool
+)
+
 const (
 	contextPackage = protogen.GoImportPath("context")
 	grpcPackage    = protogen.GoImportPath("google.golang.org/grpc")
@@ -80,7 +92,7 @@
 func (serviceGenerateHelper) generateUnimplementedServerType(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
 	serverType := service.GoName + "Server"
 	mustOrShould := "must"
-	if !*requireUnimplemented {
+	if !*RequireUnimplemented {
 		mustOrShould = "should"
 	}
 	// Server Unimplemented struct for forward compatibility.
@@ -100,7 +112,7 @@
 		g.P("return ", nilArg, statusPackage.Ident("Errorf"), "(", codesPackage.Ident("Unimplemented"), `, "method `, method.GoName, ` not implemented")`)
 		g.P("}")
 	}
-	if *requireUnimplemented {
+	if *RequireUnimplemented {
 		g.P("func (Unimplemented", serverType, ") mustEmbedUnimplemented", serverType, "() {}")
 	}
 	g.P("func (Unimplemented", serverType, ") testEmbeddedByValue() {}")
@@ -125,24 +137,24 @@
 
 var helper serviceGenerateHelperInterface = serviceGenerateHelper{}
 
-// FileDescriptorProto.package field number
+// FileDescriptorProto.package field number.
 const fileDescriptorProtoPackageFieldNumber = 2
 
-// FileDescriptorProto.syntax field number
+// FileDescriptorProto.syntax field number.
 const fileDescriptorProtoSyntaxFieldNumber = 12
 
-// generateFile generates a _grpc.pb.go file containing gRPC service definitions.
-func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
+// GenerateFile generates a _orb-grpc.pb.go file containing gRPC service definitions.
+func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
 	if len(file.Services) == 0 {
 		return nil
 	}
-	filename := file.GeneratedFilenamePrefix + "_grpc.pb.go"
+	filename := file.GeneratedFilenamePrefix + "_orb-grpc.pb.go"
 	g := gen.NewGeneratedFile(filename, file.GoImportPath)
 	// Attach all comments associated with the syntax field.
 	genLeadingComments(g, file.Desc.SourceLocations().ByPath(protoreflect.SourcePath{fileDescriptorProtoSyntaxFieldNumber}))
-	g.P("// Code generated by protoc-gen-go-grpc. DO NOT EDIT.")
+	g.P("// Code generated by protoc-gen-go-orb-grpc. DO NOT EDIT.")
 	g.P("// versions:")
-	g.P("// - protoc-gen-go-grpc v", version)
+	g.P("// - protoc-gen-go-orb  v", Version)
 	g.P("// - protoc             ", protocVersion(gen))
 	if file.Proto.GetOptions().GetDeprecated() {
 		g.P("// ", file.Desc.Path(), " is a deprecated file.")
@@ -178,7 +190,7 @@
 
 	g.P("// This is a compile-time assertion to ensure that this generated file")
 	g.P("// is compatible with the grpc package it is being compiled against.")
-	if *useGenericStreams {
+	if *UseGenericStreams {
 		g.P("// Requires gRPC-Go v1.64.0 or later.")
 		g.P("const _ = ", grpcPackage.Ident("SupportPackageIsVersion9"))
 	} else {
@@ -206,13 +218,6 @@
 	// Full methods constants.
 	helper.genFullMethods(g, service)
 
-	// Client interface.
-	clientName := service.GoName + "Client"
-
-	g.P("// ", clientName, " is the client API for ", service.GoName, " service.")
-	g.P("//")
-	g.P("// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.")
-
 	// Copy comments from proto file.
 	genServiceComments(g, service)
 
@@ -220,47 +225,9 @@
 		g.P("//")
 		g.P(deprecationComment)
 	}
-	g.AnnotateSymbol(clientName, protogen.Annotation{Location: service.Location})
-	g.P("type ", clientName, " interface {")
-	for _, method := range service.Methods {
-		g.AnnotateSymbol(clientName+"."+method.GoName, protogen.Annotation{Location: method.Location})
-		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
-			g.P(deprecationComment)
-		}
-		g.P(method.Comments.Leading,
-			clientSignature(g, method))
-	}
-	g.P("}")
-	g.P()
-
-	// Client structure.
-	helper.generateClientStruct(g, clientName)
-
-	// NewClient factory.
-	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
-		g.P(deprecationComment)
-	}
-	g.P("func New", clientName, " (cc ", grpcPackage.Ident("ClientConnInterface"), ") ", clientName, " {")
-	helper.generateNewClientDefinitions(g, service, clientName)
-	g.P("}")
-	g.P()
-
-	var methodIndex, streamIndex int
-	// Client method implementations.
-	for _, method := range service.Methods {
-		if !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
-			// Unary RPC method
-			genClientMethod(gen, file, g, method, methodIndex)
-			methodIndex++
-		} else {
-			// Streaming RPC method
-			genClientMethod(gen, file, g, method, streamIndex)
-			streamIndex++
-		}
-	}
 
 	mustOrShould := "must"
-	if !*requireUnimplemented {
+	if !*RequireUnimplemented {
 		mustOrShould = "should"
 	}
 
@@ -287,7 +254,7 @@
 		g.P(method.Comments.Leading,
 			serverSignature(g, method))
 	}
-	if *requireUnimplemented {
+	if *RequireUnimplemented {
 		g.P("mustEmbedUnimplemented", serverType, "()")
 	}
 	g.P("}")
@@ -309,7 +276,7 @@
 		g.P(deprecationComment)
 	}
 	serviceDescVar := service.GoName + "_ServiceDesc"
-	g.P("func Register", service.GoName, "Server(s ", grpcPackage.Ident("ServiceRegistrar"), ", srv ", serverType, ") {")
+	g.P("func register", service.GoName, "GRPCHandler(s ", grpcPackage.Ident("ServiceRegistrar"), ", srv ", serverType, ") {")
 	g.P("// If the following call panics, it indicates Unimplemented", serverType, " was")
 	g.P("// embedded by pointer and is nil.  This will cause panics if an")
 	g.P("// unimplemented method is ever invoked, so we test this at initialization")
@@ -324,131 +291,6 @@
 	helper.generateServerFunctions(gen, file, g, service, serverType, serviceDescVar)
 }
 
-func clientSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
-	s := method.GoName + "(ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
-	if !method.Desc.IsStreamingClient() {
-		s += ", in *" + g.QualifiedGoIdent(method.Input.GoIdent)
-	}
-	s += ", opts ..." + g.QualifiedGoIdent(grpcPackage.Ident("CallOption")) + ") ("
-	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
-		s += "*" + g.QualifiedGoIdent(method.Output.GoIdent)
-	} else {
-		if *useGenericStreams {
-			s += clientStreamInterface(g, method)
-		} else {
-			s += method.Parent.GoName + "_" + method.GoName + "Client"
-		}
-	}
-	s += ", error)"
-	return s
-}
-
-func clientStreamInterface(g *protogen.GeneratedFile, method *protogen.Method) string {
-	typeParam := g.QualifiedGoIdent(method.Input.GoIdent) + ", " + g.QualifiedGoIdent(method.Output.GoIdent)
-	if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
-		return g.QualifiedGoIdent(grpcPackage.Ident("BidiStreamingClient")) + "[" + typeParam + "]"
-	} else if method.Desc.IsStreamingClient() {
-		return g.QualifiedGoIdent(grpcPackage.Ident("ClientStreamingClient")) + "[" + typeParam + "]"
-	} else { // i.e. if method.Desc.IsStreamingServer()
-		return g.QualifiedGoIdent(grpcPackage.Ident("ServerStreamingClient")) + "[" + g.QualifiedGoIdent(method.Output.GoIdent) + "]"
-	}
-}
-
-func genClientMethod(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, method *protogen.Method, index int) {
-	service := method.Parent
-	fmSymbol := helper.formatFullMethodSymbol(service, method)
-
-	if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
-		g.P(deprecationComment)
-	}
-	g.P("func (c *", unexport(service.GoName), "Client) ", clientSignature(g, method), "{")
-	g.P("cOpts := append([]", grpcPackage.Ident("CallOption"), "{", grpcPackage.Ident("StaticMethod()"), "}, opts...)")
-	if !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
-		g.P("out := new(", method.Output.GoIdent, ")")
-		g.P(`err := c.cc.Invoke(ctx, `, fmSymbol, `, in, out, cOpts...)`)
-		g.P("if err != nil { return nil, err }")
-		g.P("return out, nil")
-		g.P("}")
-		g.P()
-		return
-	}
-
-	streamImpl := unexport(service.GoName) + method.GoName + "Client"
-	if *useGenericStreams {
-		typeParam := g.QualifiedGoIdent(method.Input.GoIdent) + ", " + g.QualifiedGoIdent(method.Output.GoIdent)
-		streamImpl = g.QualifiedGoIdent(grpcPackage.Ident("GenericClientStream")) + "[" + typeParam + "]"
-	}
-
-	serviceDescVar := service.GoName + "_ServiceDesc"
-	g.P("stream, err := c.cc.NewStream(ctx, &", serviceDescVar, ".Streams[", index, `], `, fmSymbol, `, cOpts...)`)
-	g.P("if err != nil { return nil, err }")
-	g.P("x := &", streamImpl, "{ClientStream: stream}")
-	if !method.Desc.IsStreamingClient() {
-		g.P("if err := x.ClientStream.SendMsg(in); err != nil { return nil, err }")
-		g.P("if err := x.ClientStream.CloseSend(); err != nil { return nil, err }")
-	}
-	g.P("return x, nil")
-	g.P("}")
-	g.P()
-
-	// Auxiliary types aliases, for backwards compatibility.
-	if *useGenericStreams {
-		g.P("// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.")
-		g.P("type ", service.GoName, "_", method.GoName, "Client = ", clientStreamInterface(g, method))
-		g.P()
-		return
-	}
-
-	// Stream auxiliary types and methods, if we're not taking advantage of the
-	// pre-implemented generic types and their methods.
-	genSend := method.Desc.IsStreamingClient()
-	genRecv := method.Desc.IsStreamingServer()
-	genCloseAndRecv := !method.Desc.IsStreamingServer()
-
-	g.P("type ", service.GoName, "_", method.GoName, "Client interface {")
-	if genSend {
-		g.P("Send(*", method.Input.GoIdent, ") error")
-	}
-	if genRecv {
-		g.P("Recv() (*", method.Output.GoIdent, ", error)")
-	}
-	if genCloseAndRecv {
-		g.P("CloseAndRecv() (*", method.Output.GoIdent, ", error)")
-	}
-	g.P(grpcPackage.Ident("ClientStream"))
-	g.P("}")
-	g.P()
-
-	g.P("type ", streamImpl, " struct {")
-	g.P(grpcPackage.Ident("ClientStream"))
-	g.P("}")
-	g.P()
-
-	if genSend {
-		g.P("func (x *", streamImpl, ") Send(m *", method.Input.GoIdent, ") error {")
-		g.P("return x.ClientStream.SendMsg(m)")
-		g.P("}")
-		g.P()
-	}
-	if genRecv {
-		g.P("func (x *", streamImpl, ") Recv() (*", method.Output.GoIdent, ", error) {")
-		g.P("m := new(", method.Output.GoIdent, ")")
-		g.P("if err := x.ClientStream.RecvMsg(m); err != nil { return nil, err }")
-		g.P("return m, nil")
-		g.P("}")
-		g.P()
-	}
-	if genCloseAndRecv {
-		g.P("func (x *", streamImpl, ") CloseAndRecv() (*", method.Output.GoIdent, ", error) {")
-		g.P("if err := x.ClientStream.CloseSend(); err != nil { return nil, err }")
-		g.P("m := new(", method.Output.GoIdent, ")")
-		g.P("if err := x.ClientStream.RecvMsg(m); err != nil { return nil, err }")
-		g.P("return m, nil")
-		g.P("}")
-		g.P()
-	}
-}
-
 func serverSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
 	var reqArgs []string
 	ret := "error"
@@ -460,7 +302,7 @@
 		reqArgs = append(reqArgs, "*"+g.QualifiedGoIdent(method.Input.GoIdent))
 	}
 	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
-		if *useGenericStreams {
+		if *UseGenericStreams {
 			reqArgs = append(reqArgs, serverStreamInterface(g, method))
 		} else {
 			reqArgs = append(reqArgs, method.Parent.GoName+"_"+method.GoName+"Server")
@@ -521,7 +363,7 @@
 	}
 }
 
-func genServerMethod(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, method *protogen.Method, hnameFuncNameFormatter func(string) string) string {
+func genServerMethod(_ *protogen.Plugin, _ *protogen.File, g *protogen.GeneratedFile, method *protogen.Method, hnameFuncNameFormatter func(string) string) string {
 	service := method.Parent
 	hname := fmt.Sprintf("_%s_%s_Handler", service.GoName, method.GoName)
 
@@ -545,7 +387,7 @@
 	}
 
 	streamImpl := unexport(service.GoName) + method.GoName + "Server"
-	if *useGenericStreams {
+	if *UseGenericStreams {
 		typeParam := g.QualifiedGoIdent(method.Input.GoIdent) + ", " + g.QualifiedGoIdent(method.Output.GoIdent)
 		streamImpl = g.QualifiedGoIdent(grpcPackage.Ident("GenericServerStream")) + "[" + typeParam + "]"
 	}
@@ -562,7 +404,7 @@
 	g.P()
 
 	// Auxiliary types aliases, for backwards compatibility.
-	if *useGenericStreams {
+	if *UseGenericStreams {
 		g.P("// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.")
 		g.P("type ", service.GoName, "_", method.GoName, "Server = ", serverStreamInterface(g, method))
 		g.P()
